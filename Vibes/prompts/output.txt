Contents of ../../include/common.h:
```c++
#ifndef COMMON_H
#define COMMON_H

#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <poll.h>
#include <sstream>
#include <errno.h>

// --- Constants ---
#define BUFFER_SIZE 1600    // Buffer size for receiving messages (used by both)
#define TOPIC_SIZE 50       // Maximum length of a topic name (used/validated by both)
#define MAX_CONTENT_SIZE 1500 // Maximum length of UDP message content (server parsing, subscriber info)
#define MAX_ID_SIZE 10      // Maximum length of a client ID (used/validated by both)

// --- Error Handling ---
// Prints error message based on errno and exits.
void error(const char *msg);

// --- Utility Functions (Potentially reusable) ---
// Helper function to send data reliably over a socket.
ssize_t send_all(int sockfd, const void *buf, size_t len, int flags);

#endif // COMMON_H```


Contents of ../../include/circular_buffer.h:
```c++
#ifndef CIRCULAR_BUFFER_H
#define CIRCULAR_BUFFER_H

#include <vector>
#include <string> // Include for std::string
#include <sys/types.h> // For size_t
#include <vector>  // For peek_string

// Basic circular buffer for character data
template <typename T>
class CircularBuffer {
private:
    std::vector<T> buffer;
    size_t head;       // Index of the next write position
    size_t tail;       // Index of the next read position
    size_t count;      // Number of elements currently in the buffer
    size_t capacity;   // Total capacity of the buffer

public:
    // Constructor
    explicit CircularBuffer(size_t cap);

    // Disable copy and assignment
    CircularBuffer(const CircularBuffer&) = delete;
    CircularBuffer& operator=(const CircularBuffer&) = delete;

    // Basic operations
    bool write(const char* data, size_t len); // Returns false if buffer is full
    size_t read(char* data, size_t len);      // Returns bytes actually read
    ssize_t find(char delimiter);             // Returns offset from tail, or -1 if not found
    size_t peek(char* data, size_t offset, size_t len); // Returns bytes peeked
    std::vector<T> peek_bytes(size_t offset, size_t len); // Helper to peek into a vector
    std::string substr(size_t offset, size_t len); // Get a string representation without consuming
    void consume(size_t len);                 // Removes 'len' bytes from the front (tail)

    // Status
    size_t bytes_available() const;
    size_t space_available() const;
    bool empty() const;
    bool full() const;
    void reset(); // Clears the buffer state
    void clear() { reset(); } // Add alias for clarity if used elsewhere

};

#endif // CIRCULAR_BUFFER_H```


Contents of ../../include/subscriber.h:
```c++
#ifndef SUBSCRIBER_H
#define SUBSCRIBER_H

#include "common.h" // Include shared definitions
#include <netinet/tcp.h> // For TCP_NODELAY
#include <netdb.h>       // For gethostbyname etc. (though inet_pton is used)

// No subscriber-specific structures or constants needed in the header for now

// Function declarations (send_all is now in common.h/cpp)
// void example_subscriber_function(); // If needed later

#endif // SUBSCRIBER_H
```


Contents of ../../include/server.h:
```c++
#ifndef SERVER_H
#define SERVER_H

#include "common.h" // Include shared definitions
#include "circular_buffer.h" // <<< Include Circular Buffer
#include <map>
#include <set>
#include <vector>
#include <string>
#include <netinet/tcp.h> // For TCP_NODELAY
#include <cmath>         // For pow in parseMessage
#include <iomanip>       // For setprecision in parseMessage
#include <netdb.h>       // Potentially needed for gethostbyname etc. (though not used directly now)
#include <climits>       // Potentially needed for limits (though not used directly now)


// --- Server Specific Constants ---
#define MAX_CLIENTS 100     // Maximum concurrent TCP clients

// --- Structures ---

// Structure to represent a TCP client (subscriber)
struct Subscriber {
    int socket = -1; // Initialize socket to invalid
    char id[MAX_ID_SIZE + 1];
    std::map<std::string, bool> topics;  // Map: Topic Pattern -> SF flag
    std::vector<std::string> stored_messages; // For store-and-forward
    bool connected = false;
    CircularBuffer<char> command_buffer; // <<< ADDED: Buffer for incoming commands

    // <<< ADDED: Constructor to initialize circular buffer
    Subscriber() : command_buffer(2 * BUFFER_SIZE) {} // Initialize with common buffer size
};

// Structure for holding parsed UDP message data
struct UdpMessage {
    char topic[TOPIC_SIZE + 1]; // Null terminated topic
    uint8_t type;
    char content[MAX_CONTENT_SIZE + 1]; // Raw content + potential null terminator space
    struct sockaddr_in sender_addr;
    int content_len; // Actual length of content received

    std::string formatMessage();
};

// --- Function Declarations ---

// Function to match a topic against a pattern (with wildcards '+' and '*')
bool topicMatches(const std::string& topic, const std::string& pattern);

// Function to parse UDP message content and format it into a string for subscribers
std::string parseMessage(const UdpMessage& msg);

#endif // SERVER_H```


Contents of ../../lib/common.cpp:
```c++
#include "common.h"
#include <cstdio>  // For perror
#include <cstdlib> // For exit

void error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

// Implementation of send_all
ssize_t send_all(int sockfd, const void *buf, size_t len, int flags) {
    size_t total = 0;
    const char *ptr = (const char*) buf;
    while(total < len) {
        ssize_t bytes_sent = send(sockfd, ptr + total, len - total, flags);
        if(bytes_sent < 0) {
            // If interrupted by signal, try again
            if (errno == EINTR) continue;
            // Other errors are fatal for this send operation
            perror("send_all failed"); // Print error
            return -1; // Indicate error
        }
        if (bytes_sent == 0) {
             // Socket closed or error? Should not happen with blocking sockets unless len was 0.
             // This indicates an issue, return bytes sent so far.
             std::cerr << "WARN: send returned 0" << std::endl;
             return total;
        }
        total += bytes_sent;
    }
    return total; // Success, return total bytes sent (should equal len)
}
```


Contents of ../../lib/circular_buffer.cpp:
```c++
#include "circular_buffer.h"
#include <cstring> // For memcpy
#include <algorithm> // For std::min
#include <stdexcept> // For invalid_argument
#include <vector> // Include vector for substr implementation

template <typename T>
CircularBuffer<T>::CircularBuffer(size_t cap)
    : buffer(cap), head(0), tail(0), count(0), capacity(cap)
{
    if (cap == 0) {
        throw std::invalid_argument("CircularBuffer capacity cannot be zero.");
    }
}

template <typename T>
bool CircularBuffer<T>::write(const char* data, size_t len) {
    if (len == 0) return true; // Nothing to write
    if (len > space_available()) {
        return false; // Not enough space
    }

    count += len; // Update count first

    // Write in possibly two parts (due to wrap-around)
    size_t part1_len = std::min(len, capacity - head);
    memcpy(buffer.data() + head, data, part1_len);
    head = (head + part1_len) % capacity;

    if (part1_len < len) {
        size_t part2_len = len - part1_len;
        memcpy(buffer.data() + head, data + part1_len, part2_len);
        head = (head + part2_len) % capacity;
    }

    return true;
}

template <typename T>
size_t CircularBuffer<T>::read(char* data, size_t len) {
     if (len == 0) return 0;

     size_t read_len = std::min(len, count); // Can only read what's available
     if (read_len == 0) return 0; // Nothing available

     // Read in possibly two parts
     size_t part1_len = std::min(read_len, capacity - tail);
     memcpy(data, buffer.data() + tail, part1_len);
     tail = (tail + part1_len) % capacity;
     count -= part1_len;

     if (part1_len < read_len) {
         size_t part2_len = read_len - part1_len;
         memcpy(data + part1_len, buffer.data() + tail, part2_len);
         tail = (tail + part2_len) % capacity;
         count -= part2_len;
     }

     return read_len;
}

// Returns the offset from the current tail, or -1 if not found
template <typename T>
ssize_t CircularBuffer<T>::find(char delimiter) {
    if (count == 0) return -1;

    size_t current_pos = tail;
    for (size_t i = 0; i < count; ++i) {
        if (buffer[current_pos] == delimiter) {
            return static_cast<ssize_t>(i); // Found at offset i from tail
        }
        current_pos = (current_pos + 1) % capacity;
    }

    return -1; // Not found
}


// Peeks 'len' bytes starting 'offset' bytes from the tail, returns bytes peeked
template <typename T>
size_t CircularBuffer<T>::peek(char* data, size_t offset, size_t len) {
     if (len == 0 || offset >= count) return 0;

     size_t peek_len = std::min(len, count - offset); // Adjust len to what's actually available after offset
     if (peek_len == 0) return 0;

     size_t start_pos = (tail + offset) % capacity;

     // Peek in possibly two parts
     size_t part1_len = std::min(peek_len, capacity - start_pos);
     memcpy(data, buffer.data() + start_pos, part1_len);

     if (part1_len < peek_len) {
         size_t part2_len = peek_len - part1_len;
         memcpy(data + part1_len, buffer.data(), part2_len); // Start from beginning of buffer data
     }

     return peek_len;
}

// Helper to peek into a vector
template <typename T>
std::vector<T> CircularBuffer<T>::peek_bytes(size_t offset, size_t len) {
    std::vector<T> result;
    if (len == 0 || offset >= count) return result;

    size_t peek_len = std::min(len, count - offset);
    if (peek_len == 0) return result;

    result.resize(peek_len);
    peek(result.data(), offset, peek_len); // Use the existing peek function
    return result;
}

// Creates a std::string from a portion of the buffer without consuming data
template <typename T>
std::string CircularBuffer<T>::substr(size_t offset, size_t len) {
    if (offset >= count || len == 0) {
        return ""; // Invalid offset or zero length requested
    }

    // Adjust length to not exceed available bytes after offset
    size_t actual_len = std::min(len, count - offset);
    if (actual_len == 0) {
        return "";
    }

    std::vector<T> temp_buffer = peek_bytes(offset, actual_len);
    // Construct string directly from vector iterators for efficiency
    return std::string(temp_buffer.begin(), temp_buffer.end());
}

template <typename T>
void CircularBuffer<T>::consume(size_t len) {
    size_t consume_len = std::min(len, count); // Cannot consume more than available
    if (consume_len == 0) return;

    tail = (tail + consume_len) % capacity;
    count -= consume_len;
}

template <typename T>
size_t CircularBuffer<T>::bytes_available() const {
    return count;
}

template <typename T>
size_t CircularBuffer<T>::space_available() const {
    return capacity - count;
}

template <typename T>
bool CircularBuffer<T>::empty() const {
    return count == 0;
}

template <typename T>
bool CircularBuffer<T>::full() const {
    return count == capacity;
}

template <typename T>
void CircularBuffer<T>::reset() {
    head = 0;
    tail = 0;
    count = 0;
    // buffer content doesn't need clearing, it will be overwritten
}

template class CircularBuffer<char>;
```


Contents of ../../src/subscriber.cpp:
```c++
// File: ../../src/subscriber.cpp
#include "subscriber.h"
#include "circular_buffer.h" // Include Circular Buffer
#include <cstdio>   // For setvbuf
#include <cstdlib>  // For atoi, exit

// --- Helper Function Declarations ---

// Parses command line arguments
static bool parse_arguments(int argc, char *argv[], std::string& client_id, std::string& server_ip, int& server_port);

// Sets up the TCP socket, connects to the server, and sets TCP_NODELAY
static int setup_and_connect(const std::string& server_ip, int server_port);

// Sends the client ID to the server
static bool send_client_id(int client_socket, const std::string& client_id);

// Initializes the pollfd array for monitoring stdin and the server socket
static void initialize_poll_fds(std::vector<struct pollfd>& poll_fds, int client_socket);

// Handles input from stdin (subscribe, unsubscribe, exit)
static void handle_user_input(int client_socket, bool& running);

// Receives data from the server into the circular buffer
// Returns number of bytes received, 0 on clean disconnect, -1 on error
static ssize_t receive_server_data(int client_socket, CircularBuffer<char>& server_buffer);

// Processes fully received null-terminated messages from the buffer
static void process_messages_from_buffer(CircularBuffer<char>& server_buffer);

// Handles messages received from the server socket
static void handle_server_message(int client_socket, CircularBuffer<char>& server_buffer, bool& running);

// The main loop for handling events from stdin and the server
static void subscriber_loop(int client_socket, std::vector<struct pollfd>& poll_fds);

// --- Main Client Logic ---
int main(int argc, char *argv[]) {
    // Disable stdout buffering
    setvbuf(stdout, NULL, _IONBF, BUFSIZ);

    std::string client_id;
    std::string server_ip;
    int server_port;

    if (!parse_arguments(argc, argv, client_id, server_ip, server_port)) {
        return 1;
    }

    int client_socket = setup_and_connect(server_ip, server_port);

    if (!send_client_id(client_socket, client_id)) {
        close(client_socket);
        return 1;
    }
    // Server prints connection confirmation

    std::vector<struct pollfd> poll_fds(2);
    
    initialize_poll_fds(poll_fds, client_socket);

    subscriber_loop(client_socket, poll_fds);

    // --- Clean up ---
    close(client_socket);
    // Optional: message indicating shutdown
    // std::cout << "Subscriber shut down." << std::endl;
    return 0;
}

// --- Helper Function Implementations ---

static bool parse_arguments(int argc, char *argv[], std::string& client_id, std::string& server_ip, int& server_port) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <ID_CLIENT> <IP_SERVER> <PORT_SERVER>" << std::endl;
        return false;
    }

    client_id = argv[1];
    if (client_id.length() > MAX_ID_SIZE) {
        std::cerr << "ERROR: Client ID too long (max " << MAX_ID_SIZE << " characters)." << std::endl;
        return false;
    }

    server_ip = argv[2]; // Validation happens during inet_pton

    server_port = atoi(argv[3]);
    if (server_port <= 0 || server_port > 65535) {
        std::cerr << "ERROR: Invalid server port." << std::endl;
        return false;
    }
    return true;
}

static int setup_and_connect(const std::string& server_ip, int server_port) {
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket < 0) {
        error("ERROR opening socket"); // Exits
    }

    // Disable Nagle's algorithm
    int flag = 1;
    if (setsockopt(client_socket, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) < 0) {
        perror("WARN: setsockopt TCP_NODELAY failed"); // Non-fatal
    }

    // Configure server address
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);

    if (inet_pton(AF_INET, server_ip.c_str(), &server_addr.sin_addr) <= 0) {
        close(client_socket); // Close socket before calling error
        error("ERROR invalid server IP address"); // Exits
    }

    // Connect to Server
    if (connect(client_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        close(client_socket); // Close socket before calling error
        error("ERROR connecting to server"); // Exits
    }

    return client_socket;
}

static bool send_client_id(int client_socket, const std::string& client_id) {
    // Send ID + null terminator
    if (send_all(client_socket, client_id.c_str(), client_id.length() + 1, 0) < 0) {
        // error() is not called here as send_all prints the error
        std::cerr << "ERROR sending client ID failed." << std::endl;
        return false;
    }
    return true;
}

static void initialize_poll_fds(std::vector<struct pollfd>& poll_fds, int client_socket) {
    poll_fds[0].fd = STDIN_FILENO;  // Standard input [index 0]
    poll_fds[0].events = POLLIN;
    poll_fds[0].revents = 0;
    poll_fds[1].fd = client_socket; // Server socket [index 1]
    poll_fds[1].events = POLLIN;
    poll_fds[1].revents = 0;
}

static void subscriber_loop(int client_socket, std::vector<struct pollfd>& poll_fds) {
    CircularBuffer<char> server_buffer(2 * BUFFER_SIZE); // Buffer for server messages
    bool running = true;

    while (running) {
        int poll_count = poll(poll_fds.data(), 2, -1); // Wait indefinitely
        if (poll_count < 0) {
            if (errno == EINTR) continue; // Interrupted by signal
            error("ERROR on poll"); // Exits
        }

        // Check STDIN [index 0]
        if (poll_fds[0].revents & POLLIN) {
            handle_user_input(client_socket, running);
        }

        // Check Server Socket [index 1] for data or errors
        if (poll_fds[1].revents & POLLIN) {
            handle_server_message(client_socket, server_buffer, running);
        } else if (poll_fds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) {
            std::cerr << "ERROR: Server connection error/hangup." << std::endl;
            running = false;
        }

        // Reset revents for next poll (only necessary if reusing the same struct array)
        for (auto& pfd : poll_fds) {
            pfd.revents = 0;
        }
        
    }
}

// Handles user input from stdin
static void handle_user_input(int client_socket, bool& running) {
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);
    if (fgets(buffer, BUFFER_SIZE - 1, stdin) == NULL) {
        running = false; // EOF on stdin, treat as exit command
        return;
    }

    buffer[strcspn(buffer, "\n")] = 0; // Remove trailing newline
    std::string input_line(buffer);

    // Trim whitespace
    input_line.erase(0, input_line.find_first_not_of(" \t\r\n"));
    input_line.erase(input_line.find_last_not_of(" \t\r\n") + 1);

    if (input_line.empty()) return;

    std::stringstream ss(input_line);
    std::string command_verb;
    ss >> command_verb;

    if (command_verb == "exit") {
        running = false;
    } else if (command_verb == "subscribe") {
        std::string topic;
        int sf_val = 0; // Default SF=0
        if (ss >> topic && ss.eof()) { // Expecting: subscribe <topic>
            if (topic.length() > TOPIC_SIZE) {
                std::cout << "ERROR: Topic too long (max " << TOPIC_SIZE << " characters)." << std::endl;
            } else {
                std::string cmd = "subscribe " + topic + " " + std::to_string(sf_val) + "\n";
                if (send_all(client_socket, cmd.c_str(), cmd.size(), 0) < 0) {
                    running = false; // Assume connection lost
                } else {
                    std::cout << "Subscribed to topic." << std::endl;
                }
            }
        } else {
            std::cout << "Usage: subscribe <topic>" << std::endl;
        }
    } else if (command_verb == "unsubscribe") {
        std::string topic;
        if (ss >> topic && ss.eof()) { // Expecting: unsubscribe <topic>
             if (topic.length() > TOPIC_SIZE) {
                std::cout << "ERROR: Topic too long (max " << TOPIC_SIZE << " characters)." << std::endl;
            } else {
                std::string cmd = "unsubscribe " + topic + "\n";
                if (send_all(client_socket, cmd.c_str(), cmd.size(), 0) < 0) {
                    running = false; // Assume connection lost
                } else {
                    std::cout << "Unsubscribed from topic." << std::endl;
                }
            }
        } else {
            std::cout << "Usage: unsubscribe <topic>" << std::endl;
        }
    } else {
        std::cout << "Unknown command. Available: subscribe, unsubscribe, exit." << std::endl;
    }
}

// Receives data into the buffer. Returns bytes received, 0 on disconnect, -1 on error.
static ssize_t receive_server_data(int client_socket, CircularBuffer<char>& server_buffer) {
    char recv_tmp_buffer[BUFFER_SIZE];
    memset(recv_tmp_buffer, 0, BUFFER_SIZE); // Not strictly necessary, but safe

    ssize_t bytes_received = recv(client_socket, recv_tmp_buffer, BUFFER_SIZE - 1, 0);

    if (bytes_received > 0) {
        if (!server_buffer.write(recv_tmp_buffer, bytes_received)) {
            // Buffer overflow - fatal error for the subscriber
            std::cerr << "ERROR: Subscriber buffer overflow. Server data potentially lost. Disconnecting." << std::endl;
            return -2; // Indicate buffer overflow error
        }
    } else if (bytes_received == 0) {
        // Server closed connection gracefully
        std::cerr << "Server closed connection." << std::endl;
    } else { // bytes_received < 0
        if (errno != ECONNRESET && errno != EINTR) { // EINTR should be handled by poll loop
            perror("ERROR receiving from server");
        } else if (errno == ECONNRESET) {
             std::cerr << "Server closed connection (reset)." << std::endl;
        }
        // Treat any error or reset as a disconnect signal
    }
    return bytes_received;
}

// Processes complete messages (null-terminated) from the buffer
static void process_messages_from_buffer(CircularBuffer<char>& server_buffer) {
    ssize_t null_offset;
    while ((null_offset = server_buffer.find('\0')) >= 0) {
        // Extract message up to (but not including) the null terminator
        std::string message = server_buffer.substr(0, null_offset);

        // Consume the message AND the null terminator
        server_buffer.consume(null_offset + 1);

        // Print the received message
        std::cout << message << std::endl;
    }
}


// Handles messages received from the server socket using the circular buffer
static void handle_server_message(int client_socket, CircularBuffer<char>& server_buffer, bool& running) {
    ssize_t bytes_received = receive_server_data(client_socket, server_buffer);

    if (bytes_received <= 0 || bytes_received == -2) { // Disconnect, error, or buffer overflow
        running = false; // Signal loop termination
        return;
    }

    // Process any complete messages now in the buffer
    process_messages_from_buffer(server_buffer);
}```


Contents of ../../src/server.cpp:
```c++
// File: ../../src/server.cpp
#include "server.h"
#include <algorithm> // For std::min, std::find_if
#include <cstdio>   // For setvbuf
#include <cstdlib>  // For atoi, exit
#include <csignal>  // For signal handling (related to EINTR)

// --- Type Definitions ---
using PollFds = std::vector<struct pollfd>;
using SubscribersMap = std::map<std::string, Subscriber>;
using SocketToIdMap = std::map<int, std::string>;

// --- Forward Declarations ---

// --- Socket Setup ---
struct ServerSockets { int tcp = -1; int udp = -1; };
static ServerSockets setup_server_sockets(int port);
static void close_server_sockets(const ServerSockets& sockets);

// --- Poll Initialization ---
static void initialize_poll_fds(PollFds& poll_fds, const ServerSockets& sockets);

// --- Main Loop Event Handlers ---
static void handle_stdin(bool& running);
static void handle_new_connection(int listener_socket, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id);
static void handle_udp_message(int udp_socket, SubscribersMap& subscribers);
static void handle_client_activity(PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id);

// --- Client Connection Helpers ---
static bool receive_client_id(int client_socket, std::string& client_id_str);
static void handle_reconnection(Subscriber& sub, int new_socket, const struct sockaddr_in& client_addr, PollFds& poll_fds, SocketToIdMap& socket_to_id);
static void handle_new_client(const std::string& client_id, int client_socket, const struct sockaddr_in& client_addr, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id);
static void send_stored_messages(Subscriber& sub);

// --- Client Activity Helpers ---
static void handle_client_disconnection(int client_socket, size_t poll_index, const std::string& client_id, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id);
static bool process_client_data(Subscriber& sub);
static bool process_commands_from_buffer(Subscriber& sub);
static void parse_and_execute_command(Subscriber& sub, const std::string& command_line);

// --- UDP Message Helpers ---
static bool parse_udp_datagram(const char* buffer, int bytes_received, UdpMessage& udp_msg);
static void distribute_udp_message(const UdpMessage& msg, const std::string& formatted_msg, SubscribersMap& subscribers);

// --- UdpMessage Method (Moved from header, Renamed for clarity) ---
std::string UdpMessage::formatMessage() {
    std::stringstream result_ss;
    char sender_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(this->sender_addr.sin_addr), sender_ip, INET_ADDRSTRLEN);
    result_ss << sender_ip << ":" << ntohs(this->sender_addr.sin_port) << " - ";
    result_ss << this->topic << " - ";

    switch(this->type) {
        case 0: { // INT
            if (this->content_len < 5) { result_ss << "INT - INVALID DATA"; break; }
            uint8_t sign = this->content[0];
            uint32_t net_val; memcpy(&net_val, this->content + 1, 4);
            int val = ntohl(net_val);
            if (sign == 1) val = -val;
            else if (sign != 0) { result_ss << "INT - INVALID SIGN BYTE"; break; }
            result_ss << "INT - " << val;
            break;
        }
        case 1: { // SHORT_REAL
            if (this->content_len < 2) { result_ss << "SHORT_REAL - INVALID DATA"; break; }
            uint16_t net_val; memcpy(&net_val, this->content, 2);
            float val = ntohs(net_val) / 100.0f;
            result_ss << "SHORT_REAL - " << std::fixed << std::setprecision(2) << val;
            result_ss.unsetf(std::ios_base::floatfield);
            break;
        }
        case 2: { // FLOAT
            if (this->content_len < 6) { result_ss << "FLOAT - INVALID DATA"; break; }
            uint8_t sign = this->content[0];
            uint32_t net_val; memcpy(&net_val, this->content + 1, 4);
            uint8_t power = this->content[5];
            double val = ntohl(net_val);
            if (power > 0) val *= pow(10.0, -static_cast<double>(power));
            if (sign == 1) val = -val;
            else if (sign != 0) { result_ss << "FLOAT - INVALID SIGN BYTE"; break; }
            result_ss << "FLOAT - " << std::fixed << std::setprecision(power) << val;
            result_ss.unsetf(std::ios_base::floatfield);
            break;
        }
        case 3: { // STRING
            char str_content[MAX_CONTENT_SIZE + 1];
            int len = std::min(this->content_len, MAX_CONTENT_SIZE);
            memcpy(str_content, this->content, len);
            str_content[len] = '\0';
            result_ss << "STRING - " << str_content;
            break;
        }
        default:
            result_ss << "UNKNOWN TYPE (" << (int)this->type << ")";
    }
    return result_ss.str();
}

// --- topicMatches (Unchanged) ---
bool topicMatches(const std::string& topic, const std::string& pattern) {
    std::vector<std::string> t_segs, p_segs;
    std::string segment;
    std::stringstream ss_t(topic);
    while (getline(ss_t, segment, '/')) {
        t_segs.push_back(segment);
    }
    std::stringstream ss_p(pattern);
    while (getline(ss_p, segment, '/')) {
        p_segs.push_back(segment);
    }

    size_t N = t_segs.size();
    size_t M = p_segs.size();

    // 2. Create DP rows (size M+1 for base cases)
    std::vector<bool> prev_dp(M + 1, false);
    std::vector<bool> curr_dp(M + 1, false);

    // 3. Base Case: Initialize prev_dp (representing dp[0][j])
    prev_dp[0] = true;
    for (size_t j = 1; j <= M; ++j) {
        if (p_segs[j - 1] == "*") {
            prev_dp[j] = prev_dp[j - 1];
        }
        // else prev_dp[j] remains false
    }

    // 4. Fill the "Table" Row by Row
    for (size_t i = 1; i <= N; ++i) {
        // Base case for the current row: dp[i][0] is always false for i > 0
        curr_dp[0] = false;
        for (size_t j = 1; j <= M; ++j) {
            const std::string& p_seg = p_segs[j - 1];
            const std::string& t_seg = t_segs[i - 1];

            if (p_seg == "+") {
                curr_dp[j] = prev_dp[j - 1];
            } else if (p_seg == "*") {
                // '*' can match zero segments (use curr_dp[j-1])
                // or '*' can match the current segment t_seg (use prev_dp[j])
                curr_dp[j] = curr_dp[j - 1] || prev_dp[j];
            } else {
                // Literal match required
                curr_dp[j] = (p_seg == t_seg) && prev_dp[j - 1];
            }
        }
        // Update prev_dp for the next iteration
        prev_dp = curr_dp;
        // Optional: clear curr_dp if needed, depends on loop structure
        // std::fill(curr_dp.begin(), curr_dp.end(), false); // Or rely on overwrite
    }

    // 5. Result is the last element of the last computed row (stored in prev_dp)
    return prev_dp[M];
}


// --- Main Server Logic ---
int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, BUFSIZ);

    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <PORT>" << std::endl;
        return 1;
    }
    int port = atoi(argv[1]);
    if (port <= 0 || port > 65535) {
        std::cerr << "ERROR: Invalid port number." << std::endl;
        return 1;
    }

    ServerSockets sockets = setup_server_sockets(port);
    if (sockets.tcp < 0 || sockets.udp < 0) return 1; // setup logs errors

    if (listen(sockets.tcp, MAX_CLIENTS) < 0) {
        close_server_sockets(sockets);
        error("ERROR on listen");
    }
    std::cerr << "Server started on port " << port << std::endl;

    SubscribersMap subscribers;
    PollFds poll_fds;
    SocketToIdMap socket_to_id;

    initialize_poll_fds(poll_fds, sockets);

    bool running = true;
    while (running) {
        int poll_count = poll(poll_fds.data(), poll_fds.size(), -1);
        if (poll_count < 0) { if (errno == EINTR) continue; error("ERROR on poll"); }

        // Order: Check stdin first, then listeners, then clients
        if (poll_fds[2].revents & POLLIN) { handle_stdin(running); if (!running) break; }
        if (poll_fds[0].revents & POLLIN) { handle_new_connection(sockets.tcp, poll_fds, subscribers, socket_to_id); }
        if (poll_fds[1].revents & POLLIN) { handle_udp_message(sockets.udp, subscribers); }
        handle_client_activity(poll_fds, subscribers, socket_to_id); // Check indices >= 3

        // Reset revents (can be done within handlers too, but less error prone here)
        for (auto& pfd_entry : poll_fds) pfd_entry.revents = 0;
    }

    close_server_sockets(sockets); // Close listening sockets
    // Client sockets are closed by handle_client_disconnection or implicitly here if server exits first
    // Optional: Message indicating shutdown completion
    // std::cout << "Server shut down complete." << std::endl;
    return 0;
}


// --- Socket Setup ---
static ServerSockets setup_server_sockets(int port) {
    ServerSockets sockets;
    int enable = 1;
    struct sockaddr_in server_addr;

    // TCP Socket
    sockets.tcp = socket(AF_INET, SOCK_STREAM, 0);
    if (sockets.tcp < 0) { error("ERROR opening TCP socket"); return sockets; } // error() exits
    if (setsockopt(sockets.tcp, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0) {
        close(sockets.tcp); error("ERROR setting SO_REUSEADDR on TCP"); return {-1,-1}; }

    // UDP Socket
    sockets.udp = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockets.udp < 0) { close(sockets.tcp); error("ERROR opening UDP socket"); return {-1,-1}; }
    if (setsockopt(sockets.udp, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0) {
        close(sockets.tcp); close(sockets.udp); error("ERROR setting SO_REUSEADDR on UDP"); return {-1,-1}; }

    // Address Configuration
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    // Bind Sockets
    if (bind(sockets.tcp, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        close(sockets.tcp); close(sockets.udp); error("ERROR binding TCP socket"); return {-1,-1}; }
    if (bind(sockets.udp, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        close(sockets.tcp); close(sockets.udp); error("ERROR binding UDP socket"); return {-1,-1}; }

    return sockets;
}

static void close_server_sockets(const ServerSockets& sockets) {
    if (sockets.tcp >= 0) close(sockets.tcp);
    if (sockets.udp >= 0) close(sockets.udp);
}

// --- Poll Initialization ---
static void initialize_poll_fds(PollFds& poll_fds, const ServerSockets& sockets) {
    poll_fds.clear(); // Ensure it's empty before initializing
    poll_fds.push_back({sockets.tcp, POLLIN, 0});   // TCP listening [index 0]
    poll_fds.push_back({sockets.udp, POLLIN, 0});   // UDP socket [index 1]
    poll_fds.push_back({STDIN_FILENO, POLLIN, 0}); // Standard input [index 2]
}

// --- Main Loop Event Handlers ---

// Handle STDIN commands (only "exit")
static void handle_stdin(bool& running) {
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);
    if (fgets(buffer, BUFFER_SIZE - 1, stdin) != NULL) {
        buffer[strcspn(buffer, "\n")] = 0;
        if (strcmp(buffer, "exit") == 0) {
            running = false;
        } // else: ignore unknown commands
    } else {
        // EOF or error on stdin, treat as exit
        running = false;
    }
}

// Accept new TCP connection, get client ID, handle connection/reconnection
static void handle_new_connection(int listener_socket, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id) {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_socket = accept(listener_socket, (struct sockaddr *) &client_addr, &client_len);
    if (client_socket < 0) { perror("WARN: accept failed"); return; }

    // Disable Nagle's algorithm
    int flag = 1;
    if (setsockopt(client_socket, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) < 0)
        perror("WARN: setsockopt TCP_NODELAY failed");

    std::string client_id_str;
    if (!receive_client_id(client_socket, client_id_str)) {
        // std::cerr << "WARN: Failed to receive client ID or client disconnected early." << std::endl;
        close(client_socket);
        return;
    }

    auto it = subscribers.find(client_id_str);
    if (it != subscribers.end()) { // ID exists
        if (it->second.connected) {
            std::cout << "Client " << client_id_str << " already connected." << std::endl;
            close(client_socket); // Close the new socket, keep the old one
        } else {
            handle_reconnection(it->second, client_socket, client_addr, poll_fds, socket_to_id);
        }
    } else { // New client ID
        handle_new_client(client_id_str, client_socket, client_addr, poll_fds, subscribers, socket_to_id);
    }
}

// Receive UDP message, parse it, and distribute to subscribers
static void handle_udp_message(int udp_socket, SubscribersMap& subscribers) {
    char buffer[BUFFER_SIZE];
    UdpMessage udp_msg;
    struct sockaddr_in udp_sender_addr;
    socklen_t udp_sender_len = sizeof(udp_sender_addr);

    memset(buffer, 0, BUFFER_SIZE);
    int bytes_received = recvfrom(udp_socket, buffer, BUFFER_SIZE - 1, 0,
                                (struct sockaddr *) &udp_sender_addr, &udp_sender_len);
    if (bytes_received <= 0) {
        if (bytes_received < 0) perror("WARN: recvfrom UDP failed");
        return;
    }

    // Populate UdpMessage struct from raw bytes
    if (!parse_udp_datagram(buffer, bytes_received, udp_msg)) {
        // std::cerr << "WARN: Received invalid UDP message format." << std::endl;
        return;
    }
    udp_msg.sender_addr = udp_sender_addr; // Store sender address

    // Format the message string once
    std::string formatted_msg_str = udp_msg.formatMessage();

    // Distribute message to relevant subscribers
    distribute_udp_message(udp_msg, formatted_msg_str, subscribers);
}


// Iterate through client sockets, check for activity (data/disconnect)
static void handle_client_activity(PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id) {
    char recv_tmp_buffer[BUFFER_SIZE]; // Temporary buffer for recv

    // Iterate backwards for safe removal from poll_fds
    for (int i = poll_fds.size() - 1; i >= 3; --i) {
        // Check index validity (might change due to removals) - already handled by loop condition and check below
         if (i >= (int)poll_fds.size()) continue;

        struct pollfd& pfd = poll_fds[i];
        int client_socket = pfd.fd;

        if (pfd.revents == 0) continue; // Skip sockets with no activity

        auto id_it = socket_to_id.find(client_socket);
        if (id_it == socket_to_id.end()) {
             // Should not happen if maps are consistent, indicates an issue
             // std::cerr << "WARN: No client ID found for active socket fd " << client_socket << ". Closing." << std::endl;
             close(client_socket);
             poll_fds.erase(poll_fds.begin() + i);
             continue;
        }
        std::string client_id_str = id_it->second;
        auto sub_it = subscribers.find(client_id_str);
        if (sub_it == subscribers.end()) {
            // Should not happen if maps are consistent
            // std::cerr << "WARN: No subscriber object found for client ID " << client_id_str << ". Closing." << std::endl;
            close(client_socket);
            socket_to_id.erase(id_it); // Remove from socket map too
            poll_fds.erase(poll_fds.begin() + i);
            continue;
        }
        Subscriber& sub = sub_it->second;

        bool client_disconnected = false;

        // Handle disconnection/error first
        if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
            if (sub.connected) { // Check if we haven't already marked it disconnected
                std::cout << "Client " << client_id_str << " disconnected (poll error/hup)." << std::endl;
            }
            client_disconnected = true;
        }
        // Check for incoming data
        else if (pfd.revents & POLLIN) {
            memset(recv_tmp_buffer, 0, BUFFER_SIZE); // Clear temp buffer
            int bytes_received = recv(client_socket, recv_tmp_buffer, BUFFER_SIZE - 1, 0);

            if (bytes_received <= 0) { // Disconnection or recv error
                if (bytes_received < 0 && errno != ECONNRESET && errno != EINTR) {
                    perror("WARN: recv from client failed");
                }
                 if (sub.connected) { // Log only if not already known disconnected
                     std::cout << "Client " << client_id_str << " disconnected." << std::endl;
                 }
                client_disconnected = true;
            } else { // Received data
                // Write to buffer and process commands
                if (!sub.command_buffer.write(recv_tmp_buffer, bytes_received)) {
                    std::cerr << "ERROR: Client " << client_id_str << " command buffer overflow. Disconnecting." << std::endl;
                    client_disconnected = true; // Disconnect misbehaving client
                } else if (!process_commands_from_buffer(sub)) {
                    // Error during command processing (though current parser doesn't signal errors this way)
                    // If needed, add error handling here. For now, assume success.
                }
            }
        } // End POLLIN handling

        // Cleanup if client disconnected
        if (client_disconnected) {
            handle_client_disconnection(client_socket, i, client_id_str, poll_fds, subscribers, socket_to_id);
            // The loop continues to the next index (decremented automatically by `i--`)
        }
    } // End loop through client sockets
}

// --- Client Connection Helpers ---

// Receives and validates the client ID string
static bool receive_client_id(int client_socket, std::string& client_id_str) {
    char buffer[BUFFER_SIZE]; // Use common buffer size
    memset(buffer, 0, BUFFER_SIZE);
    // Expect ID + null terminator. Read slightly more to detect overflow attempts.
    int bytes_received = recv(client_socket, buffer, MAX_ID_SIZE + 1, 0);

    if (bytes_received <= 0) { // Error or disconnect
        return false;
    }
    // Ensure received ID is null-terminated within buffer & max size
    buffer[std::min(bytes_received, MAX_ID_SIZE)] = '\0';

    // Check if ID contains problematic characters (like newline or null before end)
    if (strcspn(buffer, "\n\r\0") != (size_t)strlen(buffer)) {
         // std::cerr << "WARN: Client ID contains invalid characters." << std::endl;
         return false;
    }
     // Check if the actual ID length (before null) exceeds max size
    if (strlen(buffer) > MAX_ID_SIZE) {
        // std::cerr << "WARN: Received client ID exceeds max length." << std::endl;
        return false; // ID too long
    }


    client_id_str = buffer;
    return true;
}

// Handles a client reconnecting with an existing ID
static void handle_reconnection(Subscriber& sub, int new_socket, const struct sockaddr_in& client_addr, PollFds& poll_fds, SocketToIdMap& socket_to_id) {
    char client_ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &client_addr.sin_addr, client_ip_str, INET_ADDRSTRLEN);
    std::cout << "New client " << sub.id << " connected from "
              << client_ip_str << ":" << ntohs(client_addr.sin_port) << "." << std::endl;

    // Update the subscriber object
    sub.socket = new_socket;
    sub.connected = true;
    sub.command_buffer.reset(); // Clear any old command fragments

    // Add new socket to poll set and map
    poll_fds.push_back({new_socket, POLLIN, 0});
    socket_to_id[new_socket] = sub.id;

    // Send stored messages
    send_stored_messages(sub);
    sub.stored_messages.clear(); // Clear after attempting send
}

// Handles a new client connecting for the first time
static void handle_new_client(const std::string& client_id, int client_socket, const struct sockaddr_in& client_addr, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id) {
    char client_ip_str[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &client_addr.sin_addr, client_ip_str, INET_ADDRSTRLEN);
    std::cout << "New client " << client_id << " connected from "
              << client_ip_str << ":" << ntohs(client_addr.sin_port) << "." << std::endl;

    // Create and insert the new subscriber using operator[] which default-constructs
    Subscriber& new_sub = subscribers[client_id];

    // Populate the fields
    strncpy(new_sub.id, client_id.c_str(), MAX_ID_SIZE);
    new_sub.id[MAX_ID_SIZE] = '\0'; // Ensure null termination
    new_sub.socket = client_socket;
    new_sub.connected = true;
    // command_buffer is already initialized by the constructor

    // Add to poll set and map
    poll_fds.push_back({client_socket, POLLIN, 0});
    socket_to_id[client_socket] = client_id;
}

// Sends messages stored for SF=1 clients upon reconnection
static void send_stored_messages(Subscriber& sub) {
    for (const std::string& stored_msg : sub.stored_messages) {
        // Send message + null terminator
        ssize_t sent = send_all(sub.socket, stored_msg.c_str(), stored_msg.length() + 1, MSG_NOSIGNAL);
        if (sent < 0 || (size_t)sent != stored_msg.length() + 1) {
            if (errno != EPIPE && errno != ECONNRESET) {
                perror("WARN: send stored message failed during reconnect");
            }
            // If send fails, stop sending more stored messages for this client now
            break;
        }
    }
}

// --- Client Activity Helpers ---

// Cleans up resources associated with a disconnected client
static void handle_client_disconnection(int client_socket, size_t poll_index, const std::string& client_id, PollFds& poll_fds, SubscribersMap& subscribers, SocketToIdMap& socket_to_id) {
    close(client_socket);

    auto sub_it = subscribers.find(client_id);
    if (sub_it != subscribers.end()) {
        sub_it->second.connected = false;
        sub_it->second.socket = -1;
        sub_it->second.command_buffer.reset(); // Clear buffer on disconnect
        // Keep sub_it->second.topics and sub_it->second.stored_messages for potential reconnect
    }

    socket_to_id.erase(client_socket); // Erase using socket FD as key
    poll_fds.erase(poll_fds.begin() + poll_index); // Erase using index
}

// Reads data from client socket into buffer and processes complete commands
// Returns true if processing was successful, false if buffer write failed.
static bool process_client_data(Subscriber& sub) {
    // Note: This function is integrated into handle_client_activity now.
    // Reading into a temporary buffer happens there.
    // This function's role is now just processing commands from the buffer.
    return process_commands_from_buffer(sub);
}

// Processes newline-delimited commands from the subscriber's buffer
// Returns true (always, in current implementation)
static bool process_commands_from_buffer(Subscriber& sub) {
    ssize_t newline_offset;
    while ((newline_offset = sub.command_buffer.find('\n')) >= 0) {
        // Extract command line up to (but not including) newline
        std::string command_line = sub.command_buffer.substr(0, newline_offset);

        // Consume the command line AND the newline delimiter
        sub.command_buffer.consume(newline_offset + 1);

        // Trim whitespace (optional but robust)
        command_line.erase(0, command_line.find_first_not_of(" \t\r\n"));
        command_line.erase(command_line.find_last_not_of(" \t\r\n") + 1);

        if (command_line.empty()) continue;

        parse_and_execute_command(sub, command_line);
    }
    return true; // Indicate success (no buffer errors detected here)
}

// Parses a single command line and updates subscriber state
static void parse_and_execute_command(Subscriber& sub, const std::string& command_line) {
    std::stringstream ss(command_line);
    std::string command_verb;
    ss >> command_verb;

    if (command_verb == "subscribe") {
        std::string topic;
        int sf = -1; // Use -1 to detect missing SF value
        if (ss >> topic >> sf && (sf == 0 || sf == 1) && ss.eof()) {
            if (topic.length() > TOPIC_SIZE) {
                // Warn or ignore oversized topic
                // std::cerr << "WARN: Client " << sub.id << " oversized topic subscribe: " << topic << std::endl;
            } else {
                sub.topics[topic] = (sf == 1);
            }
        } else {
            // Warn about invalid format
            // std::cerr << "WARN: Client " << sub.id << " invalid subscribe format: " << command_line << std::endl;
        }
    } else if (command_verb == "unsubscribe") {
        std::string topic;
        if (ss >> topic && ss.eof()) {
             if (topic.length() > TOPIC_SIZE) {
                // Warn or ignore oversized topic
                // std::cerr << "WARN: Client " << sub.id << " oversized topic unsubscribe: " << topic << std::endl;
            } else {
                 sub.topics.erase(topic); // OK if topic doesn't exist
            }
        } else {
            // Warn about invalid format
            // std::cerr << "WARN: Client " << sub.id << " invalid unsubscribe format: " << command_line << std::endl;
        }
    } else {
        // Warn about unknown command
        // std::cerr << "WARN: Client " << sub.id << " unknown command: " << command_verb << std::endl;
    }
}

// --- UDP Message Helpers ---

// Parses the raw UDP datagram into the UdpMessage struct
static bool parse_udp_datagram(const char* buffer, int bytes_received, UdpMessage& udp_msg) {
    memset(&udp_msg, 0, sizeof(UdpMessage)); // Zero out the structure first

    // Topic is first TOPIC_SIZE bytes
    int topic_len_to_copy = std::min(bytes_received, TOPIC_SIZE);
    memcpy(udp_msg.topic, buffer, topic_len_to_copy);
    // Ensure null termination, even if topic fills TOPIC_SIZE exactly
    udp_msg.topic[std::min(topic_len_to_copy, TOPIC_SIZE)] = '\0';

    // Type byte is immediately after the topic space
    if (bytes_received < (TOPIC_SIZE + 1)) {
        return false; // Message too short for topic + type
    }
    udp_msg.type = (uint8_t)buffer[TOPIC_SIZE];

    // Content starts after topic and type
    udp_msg.content_len = bytes_received - (TOPIC_SIZE + 1);
    if (udp_msg.content_len < 0) udp_msg.content_len = 0; // Should not happen if previous check passed

    // Copy content, ensuring not to overflow MAX_CONTENT_SIZE
    if (udp_msg.content_len > 0) {
        int content_len_to_copy = std::min(udp_msg.content_len, MAX_CONTENT_SIZE);
        memcpy(udp_msg.content, buffer + TOPIC_SIZE + 1, content_len_to_copy);
        // Add null terminator for safety (useful for STRING type, harmless for others)
        udp_msg.content[std::min(content_len_to_copy, MAX_CONTENT_SIZE)] = '\0';
    } else {
        udp_msg.content[0] = '\0'; // Ensure content is null-terminated if empty
    }
     // Update content_len to reflect potentially truncated content
    udp_msg.content_len = std::min(udp_msg.content_len, MAX_CONTENT_SIZE);


    return true; // Successfully parsed
}

// Sends the formatted UDP message to matching subscribers
static void distribute_udp_message(const UdpMessage& msg, const std::string& formatted_msg, SubscribersMap& subscribers) {
    std::string topic_str(msg.topic);

    for (auto& pair : subscribers) {
        Subscriber& sub = pair.second;
        bool matched = false; // Track if *any* pattern matched for this subscriber

        for (const auto& topic_pair : sub.topics) {
            const std::string& pattern = topic_pair.first;
            bool sf_enabled = topic_pair.second;

            if (topicMatches(topic_str, pattern)) {
                matched = true; // A pattern matched
                if (sub.connected) {
                    ssize_t sent = send_all(sub.socket, formatted_msg.c_str(), formatted_msg.length() + 1, MSG_NOSIGNAL);
                    if (sent < 0 || (size_t)sent != formatted_msg.length() + 1) {
                         if (errno != EPIPE && errno != ECONNRESET) {
                             perror("WARN: send_all to subscriber failed");
                         }
                         // Let the main poll loop detect and handle the disconnect.
                    }
                } else if (sf_enabled) {
                    sub.stored_messages.push_back(formatted_msg);
                }
                // else: Matched, but disconnected and SF=0 -> Drop message

                // Important: Break inner loop once a match is found for this subscriber.
                // A subscriber receives the message at most once per UDP datagram.
                break;
            } // end if topicMatches
        } // end loop through subscriber's topic patterns

        // No need for goto, the inner loop break serves the purpose.
    } // end loop through subscribers
}```


Contents of ../../Makefile:
```c++
CXX := g++
CPPFLAGS := -Iinclude
CXXFLAGS := -Wall -Wextra -g -std=c++17 -fPIC
LDFLAGS := -lm

SRC_DIR := src
LIB_DIR := lib
INC_DIR := include

SOURCES_SERVER := $(SRC_DIR)/server.cpp
SOURCES_SUBSCRIBER := $(SRC_DIR)/subscriber.cpp
SOURCES_COMMON := $(LIB_DIR)/common.cpp $(LIB_DIR)/circular_buffer.cpp

OBJECTS_SERVER := $(notdir $(SOURCES_SERVER:.cpp=.o))
OBJECTS_SUBSCRIBER := $(notdir $(SOURCES_SUBSCRIBER:.cpp=.o))
OBJECTS_COMMON := $(notdir $(SOURCES_COMMON:.cpp=.o))

ALL_OBJECTS := $(OBJECTS_SERVER) $(OBJECTS_SUBSCRIBER) $(OBJECTS_COMMON)

SERVER_EXEC := server
SUBSCRIBER_EXEC := subscriber
BINARY := $(SERVER_EXEC) $(SUBSCRIBER_EXEC)

VPATH := $(SRC_DIR):$(LIB_DIR)

all: $(BINARY)

$(SERVER_EXEC): $(OBJECTS_SERVER) $(OBJECTS_COMMON)
	@echo "Linking $@..."
	$(CXX) $^ -o $@ $(LDFLAGS)  # Use CXX, $^ includes both prerequisites

$(SUBSCRIBER_EXEC): $(OBJECTS_SUBSCRIBER) $(OBJECTS_COMMON)
	@echo "Linking $@..."
	$(CXX) $^ -o $@ $(LDFLAGS) # Use CXX, $^ includes both prerequisites

%.o: %.cpp $(INC_DIR)/* Makefile
	@echo "Compiling $< (found via VPATH) --> $@"
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@ # $< is the prerequisite (.cpp)

clean:
	@echo "Cleaning up..."
	rm -f $(ALL_OBJECTS) $(BINARY) core.* *~

.PHONY: all clean
```


in server.cpp the function handle_udp_message loops through two hashmaps: subscribers and sub.topics. Do you think you can keep a hashmap but with the elements reversed so you can reduce the time complexity?
Can you make the topicMatches even more efficient? Maybe use a trie? I don't know if it is a good ideea, but make it more efficient.
Do not change the the messages of the logs
Do not use global variables
AND WHATEVER YOU DO DO NOT CHANGE THE FUNCTIONALITY OF THE CODE
