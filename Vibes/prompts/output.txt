Contents of ../../include/common.h:
```c++
#ifndef COMMON_H
#define COMMON_H

#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <poll.h>
#include <sstream>
#include <errno.h>

// --- Constants ---
#define BUFFER_SIZE 1600    // Buffer size for receiving messages (used by both)
#define TOPIC_SIZE 50       // Maximum length of a topic name (used/validated by both)
#define MAX_CONTENT_SIZE 1500 // Maximum length of UDP message content (server parsing, subscriber info)
#define MAX_ID_SIZE 10      // Maximum length of a client ID (used/validated by both)

// --- Error Handling ---
// Prints error message based on errno and exits.
void error(const char *msg);

// --- Utility Functions (Potentially reusable) ---
// Helper function to send data reliably over a socket.
ssize_t send_all(int sockfd, const void *buf, size_t len, int flags);

#endif // COMMON_H```


Contents of ../../include/circular_buffer.h:
```c++
#ifndef CIRCULAR_BUFFER_H
#define CIRCULAR_BUFFER_H

#include <vector>
#include <string> // Include for std::string
#include <sys/types.h> // For size_t
#include <vector>  // For peek_string

// Basic circular buffer for character data
template <typename T>
class CircularBuffer {
private:
    std::vector<T> buffer;
    size_t head;       // Index of the next write position
    size_t tail;       // Index of the next read position
    size_t count;      // Number of elements currently in the buffer
    size_t capacity;   // Total capacity of the buffer

public:
    // Constructor
    explicit CircularBuffer(size_t cap);

    // Disable copy and assignment
    CircularBuffer(const CircularBuffer&) = delete;
    CircularBuffer& operator=(const CircularBuffer&) = delete;

    // Basic operations
    bool write(const char* data, size_t len); // Returns false if buffer is full
    size_t read(char* data, size_t len);      // Returns bytes actually read
    ssize_t find(char delimiter);             // Returns offset from tail, or -1 if not found
    size_t peek(char* data, size_t offset, size_t len); // Returns bytes peeked
    std::vector<T> peek_bytes(size_t offset, size_t len); // Helper to peek into a vector
    std::string substr(size_t offset, size_t len); // Get a string representation without consuming
    void consume(size_t len);                 // Removes 'len' bytes from the front (tail)

    // Status
    size_t bytes_available() const;
    size_t space_available() const;
    bool empty() const;
    bool full() const;
    void reset(); // Clears the buffer state
    void clear() { reset(); } // Add alias for clarity if used elsewhere

};

#endif // CIRCULAR_BUFFER_H```


Contents of ../../include/subscriber.h:
```c++
#ifndef SUBSCRIBER_H
#define SUBSCRIBER_H

#include "common.h" // Include shared definitions
#include <netinet/tcp.h> // For TCP_NODELAY
#include <netdb.h>       // For gethostbyname etc. (though inet_pton is used)

// No subscriber-specific structures or constants needed in the header for now

// Function declarations (send_all is now in common.h/cpp)
// void example_subscriber_function(); // If needed later

#endif // SUBSCRIBER_H
```


Contents of ../../include/server.h:
```c++
#ifndef SERVER_H
#define SERVER_H

#include "common.h" // Include shared definitions
#include "circular_buffer.h" // <<< Include Circular Buffer
#include <map>
#include <set>
#include <vector>
#include <string>
#include <netinet/tcp.h> // For TCP_NODELAY
#include <cmath>         // For pow in parseMessage
#include <iomanip>       // For setprecision in parseMessage
#include <netdb.h>       // Potentially needed for gethostbyname etc. (though not used directly now)
#include <climits>       // Potentially needed for limits (though not used directly now)


// --- Server Specific Constants ---
#define MAX_CLIENTS 100     // Maximum concurrent TCP clients

// --- Structures ---

// Structure to represent a TCP client (subscriber)
struct Subscriber {
    int socket = -1; // Initialize socket to invalid
    char id[MAX_ID_SIZE + 1];
    std::map<std::string, bool> topics;  // Map: Topic Pattern -> SF flag
    std::vector<std::string> stored_messages; // For store-and-forward
    bool connected = false;
    // std::string command_buffer; // <<< REMOVED
    CircularBuffer<char> command_buffer; // <<< ADDED: Buffer for incoming commands

    // <<< ADDED: Constructor to initialize circular buffer
    Subscriber() : command_buffer(2 * BUFFER_SIZE) {} // Initialize with common buffer size
};

// Structure for holding parsed UDP message data
struct UdpMessage {
    char topic[TOPIC_SIZE + 1]; // Null terminated topic
    uint8_t type;
    char content[MAX_CONTENT_SIZE + 1]; // Raw content + potential null terminator space
    struct sockaddr_in sender_addr;
    int content_len; // Actual length of content received

    std::string parseMessage();
};

// --- Function Declarations ---

// Function to match a topic against a pattern (with wildcards '+' and '*')
bool topicMatches(const std::string& topic, const std::string& pattern);

// Function to parse UDP message content and format it into a string for subscribers
std::string parseMessage(const UdpMessage& msg);

#endif // SERVER_H```


Contents of ../../lib/common.cpp:
```c++
#include "common.h"
#include <cstdio>  // For perror
#include <cstdlib> // For exit

void error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

// Implementation of send_all
ssize_t send_all(int sockfd, const void *buf, size_t len, int flags) {
    size_t total = 0;
    const char *ptr = (const char*) buf;
    while(total < len) {
        ssize_t bytes_sent = send(sockfd, ptr + total, len - total, flags);
        if(bytes_sent < 0) {
            // If interrupted by signal, try again
            if (errno == EINTR) continue;
            // Other errors are fatal for this send operation
            perror("send_all failed"); // Print error
            return -1; // Indicate error
        }
        if (bytes_sent == 0) {
             // Socket closed or error? Should not happen with blocking sockets unless len was 0.
             // This indicates an issue, return bytes sent so far.
             std::cerr << "WARN: send returned 0" << std::endl;
             return total;
        }
        total += bytes_sent;
    }
    return total; // Success, return total bytes sent (should equal len)
}
```


Contents of ../../lib/circular_buffer.cpp:
```c++
#include "circular_buffer.h"
#include <cstring> // For memcpy
#include <algorithm> // For std::min
#include <stdexcept> // For invalid_argument
#include <vector> // Include vector for substr implementation

template <typename T>
CircularBuffer<T>::CircularBuffer(size_t cap)
    : buffer(cap), head(0), tail(0), count(0), capacity(cap)
{
    if (cap == 0) {
        throw std::invalid_argument("CircularBuffer capacity cannot be zero.");
    }
}

template <typename T>
bool CircularBuffer<T>::write(const char* data, size_t len) {
    if (len == 0) return true; // Nothing to write
    if (len > space_available()) {
        return false; // Not enough space
    }

    count += len; // Update count first

    // Write in possibly two parts (due to wrap-around)
    size_t part1_len = std::min(len, capacity - head);
    memcpy(buffer.data() + head, data, part1_len);
    head = (head + part1_len) % capacity;

    if (part1_len < len) {
        size_t part2_len = len - part1_len;
        memcpy(buffer.data() + head, data + part1_len, part2_len);
        head = (head + part2_len) % capacity;
    }

    return true;
}

template <typename T>
size_t CircularBuffer<T>::read(char* data, size_t len) {
     if (len == 0) return 0;

     size_t read_len = std::min(len, count); // Can only read what's available
     if (read_len == 0) return 0; // Nothing available

     // Read in possibly two parts
     size_t part1_len = std::min(read_len, capacity - tail);
     memcpy(data, buffer.data() + tail, part1_len);
     tail = (tail + part1_len) % capacity;
     count -= part1_len;

     if (part1_len < read_len) {
         size_t part2_len = read_len - part1_len;
         memcpy(data + part1_len, buffer.data() + tail, part2_len);
         tail = (tail + part2_len) % capacity;
         count -= part2_len;
     }

     return read_len;
}

// Returns the offset from the current tail, or -1 if not found
template <typename T>
ssize_t CircularBuffer<T>::find(char delimiter) {
    if (count == 0) return -1;

    size_t current_pos = tail;
    for (size_t i = 0; i < count; ++i) {
        if (buffer[current_pos] == delimiter) {
            return static_cast<ssize_t>(i); // Found at offset i from tail
        }
        current_pos = (current_pos + 1) % capacity;
    }

    return -1; // Not found
}


// Peeks 'len' bytes starting 'offset' bytes from the tail, returns bytes peeked
template <typename T>
size_t CircularBuffer<T>::peek(char* data, size_t offset, size_t len) {
     if (len == 0 || offset >= count) return 0;

     size_t peek_len = std::min(len, count - offset); // Adjust len to what's actually available after offset
     if (peek_len == 0) return 0;

     size_t start_pos = (tail + offset) % capacity;

     // Peek in possibly two parts
     size_t part1_len = std::min(peek_len, capacity - start_pos);
     memcpy(data, buffer.data() + start_pos, part1_len);

     if (part1_len < peek_len) {
         size_t part2_len = peek_len - part1_len;
         memcpy(data + part1_len, buffer.data(), part2_len); // Start from beginning of buffer data
     }

     return peek_len;
}

// Helper to peek into a vector
template <typename T>
std::vector<T> CircularBuffer<T>::peek_bytes(size_t offset, size_t len) {
    std::vector<T> result;
    if (len == 0 || offset >= count) return result;

    size_t peek_len = std::min(len, count - offset);
    if (peek_len == 0) return result;

    result.resize(peek_len);
    peek(result.data(), offset, peek_len); // Use the existing peek function
    return result;
}

// Creates a std::string from a portion of the buffer without consuming data
template <typename T>
std::string CircularBuffer<T>::substr(size_t offset, size_t len) {
    if (offset >= count || len == 0) {
        return ""; // Invalid offset or zero length requested
    }

    // Adjust length to not exceed available bytes after offset
    size_t actual_len = std::min(len, count - offset);
    if (actual_len == 0) {
        return "";
    }

    std::vector<T> temp_buffer = peek_bytes(offset, actual_len);
    // Construct string directly from vector iterators for efficiency
    return std::string(temp_buffer.begin(), temp_buffer.end());
}

template <typename T>
void CircularBuffer<T>::consume(size_t len) {
    size_t consume_len = std::min(len, count); // Cannot consume more than available
    if (consume_len == 0) return;

    tail = (tail + consume_len) % capacity;
    count -= consume_len;
}

template <typename T>
size_t CircularBuffer<T>::bytes_available() const {
    return count;
}

template <typename T>
size_t CircularBuffer<T>::space_available() const {
    return capacity - count;
}

template <typename T>
bool CircularBuffer<T>::empty() const {
    return count == 0;
}

template <typename T>
bool CircularBuffer<T>::full() const {
    return count == capacity;
}

template <typename T>
void CircularBuffer<T>::reset() {
    head = 0;
    tail = 0;
    count = 0;
    // buffer content doesn't need clearing, it will be overwritten
}

template class CircularBuffer<char>;
```


Contents of ../../src/subscriber.cpp:
```c++
#include "subscriber.h"
#include "circular_buffer.h" // <<< Include Circular Buffer
#include <cstdio>   // For setvbuf
#include <cstdlib>  // For atoi, exit

// --- Helper function declarations for main logic (optional modularity) ---
static void handle_user_input(int client_socket, bool& running);
// <<< MODIFIED signature
static void handle_server_message(int client_socket, CircularBuffer<char>& server_buffer, bool& running);


// --- Main Client Logic ---
int main(int argc, char *argv[]) {
    // Disable stdout buffering
    setvbuf(stdout, NULL, _IONBF, BUFSIZ);

    // --- Argument Parsing ---
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <ID_CLIENT> <IP_SERVER> <PORT_SERVER>" << std::endl;
        return 1;
    }

    std::string client_id = argv[1];
    if (client_id.length() > MAX_ID_SIZE) {
         std::cerr << "ERROR: Client ID too long (max " << MAX_ID_SIZE << " characters)." << std::endl;
         return 1;
    }
    const char* server_ip_cstr = argv[2];
    int server_port = atoi(argv[3]);
     if (server_port <= 0 || server_port > 65535) {
         std::cerr << "ERROR: Invalid server port." << std::endl;
         return 1;
    }

    // --- Socket Creation and Setup ---
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket < 0) error("ERROR opening socket");

    // Disable Nagle's algorithm
    int flag = 1;
    if (setsockopt(client_socket, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) < 0)
        perror("WARN: setsockopt TCP_NODELAY failed"); // Non-fatal

    // Configure server address
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    if (inet_pton(AF_INET, server_ip_cstr, &server_addr.sin_addr) <= 0)
        error("ERROR invalid server IP address");

    // --- Connect to Server ---
    if (connect(client_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0)
        error("ERROR connecting to server");

    // --- Send Client ID ---
    if (send_all(client_socket, client_id.c_str(), client_id.length() + 1, 0) < 0) {
        error("ERROR sending client ID"); // send_all prints details via perror
    }
    // Server prints connection confirmation

    // --- Polling Setup ---
    struct pollfd poll_fds[2];
    poll_fds[0].fd = STDIN_FILENO;  // Standard input [index 0]
    poll_fds[0].events = POLLIN;
    poll_fds[1].fd = client_socket; // Server socket [index 1]
    poll_fds[1].events = POLLIN;

    // std::string server_buffer; // <<< REMOVED
    CircularBuffer<char> server_buffer(2 * BUFFER_SIZE); // <<< ADDED: Circular buffer for server messages
    bool running = true;

    // --- Main Client Loop ---
    while (running) {
        // Wait indefinitely for events
        int poll_count = poll(poll_fds, 2, -1);
        if (poll_count < 0) {
             if (errno == EINTR) continue; // Interrupted by signal
             error("ERROR on poll");
        }

        // Check STDIN [index 0]
        if (poll_fds[0].revents & POLLIN) {
            handle_user_input(client_socket, running);
        }

        // Check Server Socket [index 1] for data or errors
        if (poll_fds[1].revents & POLLIN) {
             // <<< MODIFIED: Pass circular buffer
            handle_server_message(client_socket, server_buffer, running);
        } else if (poll_fds[1].revents & (POLLERR | POLLHUP | POLLNVAL)) {
             std::cerr << "ERROR: Server connection error/hangup." << std::endl;
             running = false;
        }

        // Reset revents for next poll
        poll_fds[0].revents = 0;
        poll_fds[1].revents = 0;

    } // End while(running)

    // --- Clean up ---
    close(client_socket);
    // Optional: message indicating shutdown
    // std::cout << "Subscriber shut down." << std::endl;
    return 0;
}


// --- Helper Function Implementations ---

// handle_user_input remains the same
static void handle_user_input(int client_socket, bool& running) {
    // ... (implementation unchanged) ...
    char buffer[BUFFER_SIZE]; // Use common buffer size
    memset(buffer, 0, BUFFER_SIZE);
    if (fgets(buffer, BUFFER_SIZE - 1, stdin) == NULL) {
         // EOF on stdin, treat as exit command
         running = false;
         return;
    }

    // Remove trailing newline
    buffer[strcspn(buffer, "\n")] = 0;
    std::string input_line(buffer);

    // Trim whitespace (optional but robust)
    input_line.erase(0, input_line.find_first_not_of(" \t\r\n"));
    input_line.erase(input_line.find_last_not_of(" \t\r\n") + 1);

    if (input_line.empty()) return; // Ignore empty lines

    std::stringstream ss(input_line);
    std::string command_verb;
    ss >> command_verb;

    if (command_verb == "exit") {
        running = false;
    } else if (command_verb == "subscribe") {
        std::string topic;
        int sf_val = 0; // Default SF is 0 according to original logic
        // Check format: subscribe <topic> [<sf>] (original logic only had <topic>)
        // We will stick to original: subscribe <topic> implies SF=0
        if (ss >> topic && ss.eof()) { // Only topic expected
            if (topic.length() > TOPIC_SIZE) {
                std::cout << "ERROR: Topic too long (max " << TOPIC_SIZE << " characters)." << std::endl;
            } else {
                // Format command string for server (subscribe <topic> <sf>\n)
                std::string cmd = "subscribe " + topic + " " + std::to_string(sf_val) + "\n";
                if (send_all(client_socket, cmd.c_str(), cmd.size(), 0) < 0) {
                    // Error already printed by send_all
                    running = false; // Assume connection lost
                } else {
                    std::cout << "Subscribed to topic." << std::endl;
                }
            }
        } else {
            std::cout << "Usage: subscribe <topic>" << std::endl;
        }
    } else if (command_verb == "unsubscribe") {
        std::string topic;
        // Check format: unsubscribe <topic>
        if (ss >> topic && ss.eof()) {
             if (topic.length() > TOPIC_SIZE) {
                std::cout << "ERROR: Topic too long (max " << TOPIC_SIZE << " characters)." << std::endl;
            } else {
                 // Format command string for server (unsubscribe <topic>\n)
                std::string cmd = "unsubscribe " + topic + "\n";
                if (send_all(client_socket, cmd.c_str(), cmd.size(), 0) < 0) {
                    // Error already printed by send_all
                    running = false; // Assume connection lost
                } else {
                    std::cout << "Unsubscribed from topic." << std::endl;
                }
            }
        } else {
            std::cout << "Usage: unsubscribe <topic>" << std::endl;
        }
    } else {
        std::cout << "Unknown command. Available: subscribe, unsubscribe, exit." << std::endl;
    }
}


// MODIFIED handle_server_message
static void handle_server_message(int client_socket, CircularBuffer<char>& server_buffer, bool& running) {
    char recv_tmp_buffer[BUFFER_SIZE]; // <<< Use a temporary buffer for recv
    memset(recv_tmp_buffer, 0, BUFFER_SIZE); // Clear temp buffer
    int bytes_received = recv(client_socket, recv_tmp_buffer, BUFFER_SIZE - 1, 0);

    if (bytes_received <= 0) {
        if (bytes_received < 0 && errno != ECONNRESET) {
            perror("ERROR receiving from server");
        }
        // If 0 or error, server has disconnected
        if (bytes_received == 0) {
             std::cerr << "Server closed connection." << std::endl;
        }
        running = false;
        return;
    }

    // <<< MODIFIED: Use Circular Buffer >>>
    // Write received data into the circular buffer
    if (!server_buffer.write(recv_tmp_buffer, bytes_received)) {
         // Buffer full! This means the subscriber isn't processing messages fast enough
         // or the server sent a massive burst. Treat as fatal error.
         std::cerr << "ERROR: Subscriber buffer overflow. Server data potentially lost. Disconnecting." << std::endl;
         running = false;
         return;
    }

    // Process complete messages (null-terminated) from the buffer
    ssize_t null_offset; // Use ssize_t for find result (-1 if not found)
    while ((null_offset = server_buffer.find('\0')) >= 0) {
         // Extract message up to (but not including) the null terminator
         // null_offset is the length of the message string
         std::string message = server_buffer.substr(0, null_offset);

         // Consume the message AND the null terminator from the buffer
         server_buffer.consume(null_offset + 1);

         // Print the received message
         std::cout << message << std::endl;
    }
    // <<< END MODIFIED SECTION >>>
}```


Contents of ../../src/server.cpp:
```c++

#include "server.h"
#include <algorithm> // For std::min
#include <cstdio>   // For setvbuf
#include <cstdlib>  // For atoi, exit
#include <csignal>  // For signal handling (related to EINTR)

// --- Function Implementations ---

// topicMatches remains the same
bool topicMatches(const std::string& topic, const std::string& pattern) {
    // ... (implementation unchanged) ...
    std::vector<std::string> p_segs, t_segs;
    std::string segment;
    std::stringstream ss_p(pattern);
    while (getline(ss_p, segment, '/')) p_segs.push_back(segment);
    std::stringstream ss_t(topic);
    while (getline(ss_t, segment, '/')) t_segs.push_back(segment);

    size_t p_idx = 0, t_idx = 0;
    while (p_idx < p_segs.size() && t_idx < t_segs.size()) {
        if (p_segs[p_idx] == "+") {
            // '+' matches exactly one segment
            p_idx++;
            t_idx++;
        } else if (p_segs[p_idx] == "*") {
            // '*' matches zero or more segments
            p_idx++;
            if (p_idx == p_segs.size()) return true; // '*' at end matches rest

            // Try matching remaining pattern against remaining topic segments
            while (t_idx < t_segs.size()) {
                 // Construct remaining topic/pattern strings for recursive-like check
                 std::string remaining_topic = "";
                 for(size_t i = t_idx; i < t_segs.size(); ++i) remaining_topic += (i > t_idx ? "/" : "") + t_segs[i];
                 std::string remaining_pattern = "";
                 for(size_t i = p_idx; i < p_segs.size(); ++i) remaining_pattern += (i > p_idx ? "/" : "") + p_segs[i];

                 if (topicMatches(remaining_topic, remaining_pattern)) {
                     return true;
                 }
                 t_idx++; // '*' consumes one segment, try again
            }
            return false; // Ran out of topic segments to match remaining pattern
        } else {
            // Segments must match exactly
            if (p_segs[p_idx] != t_segs[t_idx]) return false;
            p_idx++;
            t_idx++;
        }
    }

    // Handle trailing '*' matching zero segments
    if (t_idx == t_segs.size() && p_idx < p_segs.size() && p_segs[p_idx] == "*" && p_idx == p_segs.size() - 1) {
        p_idx++;
    }

    // Both pattern and topic must be fully consumed for a match
    return p_idx == p_segs.size() && t_idx == t_segs.size();
}

// UdpMessage::parseMessage remains the same
std::string UdpMessage::parseMessage() {
    // ... (implementation unchanged) ...
    std::stringstream result_ss; // Use stringstream for easier formatting

    // Add IP and port of sender
    char sender_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(this->sender_addr.sin_addr), sender_ip, INET_ADDRSTRLEN);
    result_ss << sender_ip << ":" << ntohs(this->sender_addr.sin_port) << " - ";

    // Add topic
    result_ss << this->topic << " - ";

    // Parse content based on type
    switch(this->type) {
        case 0: {  // INT
            if (this->content_len < 5) { // Need 1 byte sign + 4 bytes value
                 result_ss << "INT - INVALID DATA";
                 break;
            }
            uint8_t sign_byte = this->content[0];
            uint32_t net_value;
            memcpy(&net_value, this->content + 1, sizeof(uint32_t)); // Copy value after sign byte
            int value = ntohl(net_value); // Convert from network byte order
            if (sign_byte == 1) {
                value = -value; // Apply sign
            } else if (sign_byte != 0) {
                result_ss << "INT - INVALID SIGN BYTE";
                break;
            }
            result_ss << "INT - " << value;
            break;
        }
        case 1: {  // SHORT_REAL
             if (this->content_len < 2) { // Need 2 bytes value
                 result_ss << "SHORT_REAL - INVALID DATA";
                 break;
            }
            uint16_t net_value;
            memcpy(&net_value, this->content, sizeof(uint16_t));
            float value = ntohs(net_value) / 100.0f; // Convert and scale
            // Format to two decimal places, ensuring trailing zeros if needed
            result_ss << "SHORT_REAL - " << std::fixed << std::setprecision(2) << value;
            result_ss.unsetf(std::ios_base::floatfield); // Reset float formatting
            break;
        }
        case 2: {  // FLOAT
             if (this->content_len < 6) { // Need 1 byte sign + 4 bytes value + 1 byte power
                 result_ss << "FLOAT - INVALID DATA";
                 break;
             }
             uint8_t sign_byte = this->content[0];
             uint32_t net_value;
             memcpy(&net_value, this->content + 1, sizeof(uint32_t));
             uint8_t power_byte = this->content[5];

             double value = ntohl(net_value);
             if (power_byte > 0) {
                 value *= pow(10.0, -static_cast<double>(power_byte));
             }

             if (sign_byte == 1) {
                 value = -value;
             } else if (sign_byte != 0) {
                 result_ss << "FLOAT - INVALID SIGN BYTE";
                 break;
             }
             // Print exactly power_byte decimals
             result_ss << "FLOAT - "
                       << std::fixed << std::setprecision(power_byte)
                       << value;
             // Reset floatfield so it doesn't leak into next prints
             result_ss.unsetf(std::ios_base::floatfield);
             break;
        }
        case 3: {  // STRING
            char string_content[MAX_CONTENT_SIZE + 1];
            int len_to_copy = std::min(this->content_len, MAX_CONTENT_SIZE);
            memcpy(string_content, this->content, len_to_copy);
            string_content[len_to_copy] = '\0';
            result_ss << "STRING - " << string_content;
            break;
        }
        default:
            result_ss << "UNKNOWN TYPE (" << (int)this->type << ")";
    }

    return result_ss.str();
}

static void handle_stdin(bool& running);
static void handle_new_connection(int tcp_socket,
                                  std::vector<struct pollfd>& poll_fds,
                                  std::map<std::string, Subscriber>& subscribers,
                                  std::map<int, std::string>& socket_to_id);
static void handle_udp_message(int udp_socket,
                               std::map<std::string, Subscriber>& subscribers);
static void handle_client_activity(std::vector<struct pollfd>& poll_fds,
                                   std::map<std::string, Subscriber>& subscribers,
                                   std::map<int, std::string>& socket_to_id);

// --- Main Server Logic ---
// main remains the same
int main(int argc, char *argv[]) {
    // ... (implementation unchanged) ...
    // Disable stdout buffering for immediate output
    setvbuf(stdout, NULL, _IONBF, BUFSIZ);

    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <PORT>" << std::endl;
        return 1;
    }

    int port = atoi(argv[1]);
    if (port <= 0 || port > 65535) { // Basic port validation
         std::cerr << "ERROR: Invalid port number." << std::endl;
         return 1;
    }

    // --- Socket Creation and Setup ---
    int tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (tcp_socket < 0) error("ERROR opening TCP socket");

    int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket < 0) error("ERROR opening UDP socket");

    // Allow address reuse for quicker restarts
    int enable = 1;
    if (setsockopt(tcp_socket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0)
        error("ERROR setting SO_REUSEADDR on TCP");
    if (setsockopt(udp_socket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0)
        error("ERROR setting SO_REUSEADDR on UDP");

    // Server address configuration
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = INADDR_ANY; // Listen on all interfaces

    // Bind sockets
    if (bind(tcp_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0)
        error("ERROR binding TCP socket");
    if (bind(udp_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0)
        error("ERROR binding UDP socket");

    // Listen for TCP connections
    if (listen(tcp_socket, MAX_CLIENTS) < 0) error("ERROR on listen");

    std::cerr << "Server started on port " << port << std::endl;

    // --- Data Structures ---
    std::map<std::string, Subscriber> subscribers; // Map ID to Subscriber struct
    std::vector<struct pollfd> poll_fds;           // File descriptors for polling
    std::map<int, std::string> socket_to_id;       // Map socket fd to client ID

    // Add initial sockets to poll set
    poll_fds.push_back({tcp_socket, POLLIN, 0});   // TCP listening [index 0]
    poll_fds.push_back({udp_socket, POLLIN, 0});   // UDP socket [index 1]
    poll_fds.push_back({STDIN_FILENO, POLLIN, 0}); // Standard input [index 2]

    bool running = true;

    // --- Main Server Loop ---
    while (running) {
        // Wait for events
        int poll_count = poll(poll_fds.data(), poll_fds.size(), -1);
        if (poll_count < 0) {
            if (errno == EINTR) continue; // Interrupted by signal
            error("ERROR on poll");
        }

        // Check STDIN [index 2]
        if (poll_fds[2].revents & POLLIN) {
            handle_stdin(running);
            if (!running) break; // Exit immediately if requested
        }

        // Check TCP listener [index 0]
        if (poll_fds[0].revents & POLLIN) {
            handle_new_connection(tcp_socket, poll_fds, subscribers, socket_to_id);
        }

        // Check UDP socket [index 1]
        if (poll_fds[1].revents & POLLIN) {
            handle_udp_message(udp_socket, subscribers);
        }

        // Check client TCP sockets [indices >= 3]
        handle_client_activity(poll_fds, subscribers, socket_to_id);

        // Clean up revents for the next iteration (important!)
        for (auto& pfd_entry : poll_fds) {
            pfd_entry.revents = 0;
        }
    } // End main while loop (running)

    // --- Server Shutdown ---
    // Close all client sockets first (indices >= 3)
    for (size_t i = 3; i < poll_fds.size(); ++i) {
         close(poll_fds[i].fd);
    }
    // Close listening/UDP sockets
    close(tcp_socket);
    close(udp_socket);

    // Optional: Message indicating shutdown completion
    // std::cout << "Server shut down complete." << std::endl;

    return 0;
}

// --- Helper Function Implementations ---

// handle_stdin remains the same
static void handle_stdin(bool& running) {
    // ... (implementation unchanged) ...
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);
    if (fgets(buffer, BUFFER_SIZE - 1, stdin) != NULL) {
        buffer[strcspn(buffer, "\n")] = 0; // Remove trailing newline
        if (strcmp(buffer, "exit") == 0) {
            running = false; // Signal shutdown
        } else {
            // Unknown command (optional: log)
            // std::cerr << "Unknown command on server stdin: " << buffer << std::endl;
        }
    } else {
        // EOF or error on stdin
        // std::cerr << "WARN: STDIN closed or error." << std::endl;
        running = false; // Treat as exit signal
    }
}

// MODIFIED handle_new_connection
static void handle_new_connection(int tcp_socket,
                                  std::vector<struct pollfd>& poll_fds,
                                  std::map<std::string, Subscriber>& subscribers,
                                  std::map<int, std::string>& socket_to_id)
{
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_socket = accept(tcp_socket, (struct sockaddr *) &client_addr, &client_len);

    if (client_socket < 0) {
         perror("WARN: accept failed");
         return;
    }

    // Disable Nagle's algorithm
    int flag = 1;
    if (setsockopt(client_socket, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) < 0)
        perror("WARN: setsockopt TCP_NODELAY failed");

    // Receive client ID
    char buffer[BUFFER_SIZE]; // Use common buffer size
    memset(buffer, 0, BUFFER_SIZE);
    int bytes_received = recv(client_socket, buffer, MAX_ID_SIZE + 1, 0); // Read ID + potential null

    if (bytes_received <= 0) {
        // std::cerr << "WARN: Failed to receive client ID or client disconnected." << std::endl;
        close(client_socket);
        return;
    }

    buffer[std::min(bytes_received, MAX_ID_SIZE)] = '\0'; // Ensure null termination within limits
    std::string client_id_str(buffer);

    // --- Client Connection Logic ---
    auto it = subscribers.find(client_id_str);
    if (it != subscribers.end()) { // ID exists
        if (it->second.connected) { // Already connected?
            std::cout << "Client " << client_id_str << " already connected." << std::endl;
            close(client_socket);
        } else { // Reconnection
            char client_ip_str[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &client_addr.sin_addr, client_ip_str, INET_ADDRSTRLEN);
            std::cout << "New client " << client_id_str << " connected from "
                      << client_ip_str << ":" << ntohs(client_addr.sin_port) << "." << std::endl;

            // Update the existing subscriber object IN PLACE
            it->second.socket = client_socket;
            it->second.connected = true;
            it->second.command_buffer.reset(); // Reset buffer
            poll_fds.push_back({client_socket, POLLIN, 0}); // Add to poll set
            socket_to_id[client_socket] = client_id_str; // Update map (this map is fine)

            // Send stored messages (SF)
            for (const std::string& stored_msg : it->second.stored_messages) {
                ssize_t sent = send_all(client_socket, stored_msg.c_str(), stored_msg.length() + 1, MSG_NOSIGNAL);
                if (sent < 0 || (size_t)sent != stored_msg.length() + 1) {
                    perror("WARN: send stored message failed during reconnect");
                    break;
                }
            }
            it->second.stored_messages.clear(); // Clear after attempting send
        }
    } else { // New client ID
        // <<< CORRECTED LOGIC for new client >>>
        // Use operator[]: If client_id_str is new, it default-constructs
        // a Subscriber IN PLACE in the map and returns a reference.
        // If it somehow already existed (shouldn't happen due to find check),
        // it returns a reference to the existing one.
        Subscriber& new_map_sub = subscribers[client_id_str];

        // Now populate the fields of the subscriber object *already in the map*
        char client_ip_str[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip_str, INET_ADDRSTRLEN);
        std::cout << "New client " << client_id_str << " connected from "
                  << client_ip_str << ":" << ntohs(client_addr.sin_port) << "." << std::endl;

        strncpy(new_map_sub.id, client_id_str.c_str(), MAX_ID_SIZE);
        new_map_sub.id[MAX_ID_SIZE] = '\0'; // Ensure null termination
        new_map_sub.socket = client_socket;
        new_map_sub.connected = true;
        // new_map_sub.command_buffer was already initialized by the default
        // constructor when operator[] created the element in the map.
        // No need to reset it here.

        // Add to other structures
        poll_fds.push_back({client_socket, POLLIN, 0}); // Add to poll set
        socket_to_id[client_socket] = client_id_str; // Add to socket->ID map (this map is fine)
        // <<< END CORRECTED LOGIC >>>
    }

}

// handle_udp_message remains the same
static void handle_udp_message(int udp_socket,
                               std::map<std::string, Subscriber>& subscribers) {
    // ... (implementation unchanged) ...
    char buffer[BUFFER_SIZE]; // Use common buffer size
    UdpMessage udp_msg;
    struct sockaddr_in udp_sender_addr;
    socklen_t udp_sender_len = sizeof(udp_sender_addr);

    memset(buffer, 0, BUFFER_SIZE);
    int bytes_received = recvfrom(udp_socket, buffer, BUFFER_SIZE - 1, 0,
                                (struct sockaddr *) &udp_sender_addr, &udp_sender_len);

    if (bytes_received <= 0) {
        if (bytes_received < 0) perror("WARN: recvfrom UDP failed");
        return; // Nothing received or error
    }

    // Basic validation: must have topic (min 1 char) + type byte + content (min 0)
    // The UDP format is topic[50] + type[1] + content[1500]
    if (bytes_received < (TOPIC_SIZE + 1)) {
        // std::cerr << "WARN: Received UDP message too short (less than topic+type)." << std::endl;
        // The original code had a similar check but allowed processing. Let's stick to that.
        // However, ensure we don't read past the received bytes.
    }

    // Populate UdpMessage struct
    memset(&udp_msg, 0, sizeof(UdpMessage));
    // Copy topic carefully, ensuring null termination within TOPIC_SIZE
    int topic_len_to_copy = std::min(bytes_received, TOPIC_SIZE);
    memcpy(udp_msg.topic, buffer, topic_len_to_copy);
    udp_msg.topic[topic_len_to_copy < TOPIC_SIZE ? topic_len_to_copy : TOPIC_SIZE] = '\0'; // Ensure null term

    // Check if we have enough bytes for the type
    if (bytes_received < TOPIC_SIZE + 1) {
         // std::cerr << "WARN: UDP message too short to contain type byte." << std::endl;
         return; // Cannot process further
    }

    udp_msg.type = (uint8_t)buffer[TOPIC_SIZE];
    udp_msg.sender_addr = udp_sender_addr;
    udp_msg.content_len = bytes_received - (TOPIC_SIZE + 1);

    // Copy content only if content_len is positive and valid
    if (udp_msg.content_len > 0) {
        int len_to_copy = std::min(udp_msg.content_len, MAX_CONTENT_SIZE);
        memcpy(udp_msg.content, buffer + TOPIC_SIZE + 1, len_to_copy);
        // Ensure null termination for string safety, although binary data might not need it
        udp_msg.content[std::min(len_to_copy, MAX_CONTENT_SIZE)] = '\0';
    } else {
        udp_msg.content_len = 0;
        udp_msg.content[0] = '\0';
    }

    // Format the message string once
    std::string formatted_msg_str = udp_msg.parseMessage();
    std::string topic_str(udp_msg.topic);

    // --- Distribute message to relevant subscribers ---
    for (auto& pair : subscribers) {
        Subscriber& sub = pair.second;
        // Find if any subscription matches
        for (const auto& topic_pair : sub.topics) {
            const std::string& pattern = topic_pair.first;
            bool sf_enabled = topic_pair.second;

            if (topicMatches(topic_str, pattern)) {
                if (sub.connected) { // Send if connected
                    // Send message + null terminator
                    // Use send_all for robustness, though original used send
                    ssize_t sent = send_all(sub.socket, formatted_msg_str.c_str(), formatted_msg_str.length() + 1, MSG_NOSIGNAL);
                     if (sent < 0 || (size_t)sent != formatted_msg_str.length() + 1) {
                        // Error sending, probably disconnected
                        if (errno != EPIPE && errno != ECONNRESET) { // EPIPE/ECONNRESET common on disconnect
                            perror("WARN: send_all to subscriber failed");
                        }
                        // Let the main poll loop handle the disconnect detection
                    }
                } else if (sf_enabled) { // Store if SF=1 and disconnected
                    sub.stored_messages.push_back(formatted_msg_str);
                }
                // else: Matched, but disconnected and SF=0 -> Message dropped for this sub

                // Optimization: Once a matching pattern is found for a subscriber,
                // send/store/drop it and move to the next subscriber.
                // A subscriber receives a message at most once per UDP datagram.
                goto next_subscriber; // Use goto for clarity in breaking outer loop
            }
        } // End loop through subscriber's topics
        next_subscriber:; // Label for goto
    } // End loop through subscribers
}


// MODIFIED handle_client_activity
static void handle_client_activity(std::vector<struct pollfd>& poll_fds,
                                   std::map<std::string, Subscriber>& subscribers,
                                   std::map<int, std::string>& socket_to_id)
{
    char recv_tmp_buffer[BUFFER_SIZE]; // <<< Use a temporary buffer for recv

    // Iterate backwards to allow safe removal from poll_fds using erase
    for (int i = poll_fds.size() - 1; i >= 3; --i) {
        // Check if index is still valid after potential erasures
        if (i >= (int)poll_fds.size()) continue;

        struct pollfd& pfd = poll_fds[i];
        int client_socket = pfd.fd;

        // Skip if no event for this fd in this poll cycle
        if (pfd.revents == 0) continue;

        // Find the subscriber associated with this socket
        auto id_it = socket_to_id.find(client_socket);
        Subscriber* sub_ptr = nullptr;
        std::string client_id_str = "";
        if (id_it != socket_to_id.end()) {
            client_id_str = id_it->second;
            auto sub_it = subscribers.find(client_id_str);
            if (sub_it != subscribers.end()) {
                sub_ptr = &sub_it->second;
            }
        }

        bool client_disconnected = false;

        if (!sub_ptr) {
            // Client ID not found for this socket, should not happen if maps are consistent
            // std::cerr << "WARN: No subscriber found for active socket fd " << client_socket << std::endl;
            client_disconnected = true; // Treat as error, close it
            goto cleanup; // Skip to cleanup
        }

        // Handle disconnection/error first
        if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
             if (sub_ptr->connected) { // Check if already marked disconnected
                std::cout << "Client " << client_id_str << " disconnected (poll error/hup)." << std::endl;
                sub_ptr->connected = false;
                sub_ptr->socket = -1;
                sub_ptr->command_buffer.reset(); // <<< MODIFIED: Reset buffer
            }
            client_disconnected = true;
        }
        // Check for incoming data
        else if (pfd.revents & POLLIN) {
            memset(recv_tmp_buffer, 0, BUFFER_SIZE); // Clear temp buffer
            int bytes_received = recv(client_socket, recv_tmp_buffer, BUFFER_SIZE - 1, 0);

            if (bytes_received <= 0) { // Disconnection or error
                if (bytes_received < 0 && errno != ECONNRESET) { // ECONNRESET is common for disconnect
                     perror("WARN: recv from client failed");
                }

                if (sub_ptr->connected) {
                    std::cout << "Client " << client_id_str << " disconnected." << std::endl;
                    sub_ptr->connected = false;
                    sub_ptr->socket = -1;
                    sub_ptr->command_buffer.reset(); // <<< MODIFIED: Reset buffer
                }
                client_disconnected = true;

            } else { // Received data from client
                 // <<< MODIFIED: Use Circular Buffer >>>
                // Write received data into the client's circular buffer
                if (!sub_ptr->command_buffer.write(recv_tmp_buffer, bytes_received)) {
                    // Buffer full! This indicates a problem (e.g., client flooding server).
                    std::cerr << "ERROR: Client " << client_id_str << " command buffer overflow. Disconnecting." << std::endl;
                    // Optionally log more details
                    client_disconnected = true; // Disconnect misbehaving client
                    // command_buffer state is now potentially corrupt, reset it on disconnect below
                } else {
                    // Process complete commands (delimited by newline) from the buffer
                    ssize_t newline_offset; // Use ssize_t for find result (-1 if not found)
                    while ((newline_offset = sub_ptr->command_buffer.find('\n')) >= 0) {
                        // Extract command line up to (but not including) newline
                        // newline_offset is the length of the command string
                        std::string command_line = sub_ptr->command_buffer.substr(0, newline_offset);

                        // Consume the command line AND the newline delimiter from the buffer
                        sub_ptr->command_buffer.consume(newline_offset + 1);

                        // Trim whitespace (optional but robust) - NO CHANGE HERE
                        command_line.erase(0, command_line.find_first_not_of(" \t\r\n"));
                        command_line.erase(command_line.find_last_not_of(" \t\r\n") + 1);

                        if (command_line.empty()) continue;

                        // Parse command - NO CHANGE IN PARSING LOGIC
                        std::stringstream ss(command_line);
                        std::string command_verb;
                        ss >> command_verb;

                        if (command_verb == "subscribe") {
                            std::string topic;
                            int sf = -1;
                            if (ss >> topic >> sf && (sf == 0 || sf == 1) && ss.eof()) {
                                if (topic.length() > TOPIC_SIZE) {
                                    // std::cerr << "WARN: Client " << client_id_str << " oversized topic subscribe." << std::endl;
                                } else {
                                    sub_ptr->topics[topic] = (sf == 1);
                                }
                            } else {
                                 // std::cerr << "WARN: Client " << client_id_str << " invalid subscribe format: " << command_line << std::endl;
                            }
                        } else if (command_verb == "unsubscribe") {
                            std::string topic;
                            if (ss >> topic && ss.eof()) {
                                if (topic.length() > TOPIC_SIZE) {
                                    // std::cerr << "WARN: Client " << client_id_str << " oversized topic unsubscribe." << std::endl;
                                } else {
                                    sub_ptr->topics.erase(topic); // erase returns 0 if key not found
                                }
                            } else {
                                // std::cerr << "WARN: Client " << client_id_str << " invalid unsubscribe format: " << command_line << std::endl;
                            }
                        } else {
                             // std::cerr << "WARN: Client " << client_id_str << " unknown command: " << command_verb << std::endl;
                        }
                    } // End while processing commands from buffer
                } // End if buffer write successful
                // <<< END MODIFIED SECTION >>>
            } // End handling received data
        } // End handling POLLIN

        cleanup:;    // Cleanup label for goto
        // Cleanup if client disconnected or error occurred
        if (client_disconnected) {
            close(client_socket);
            if (sub_ptr && !sub_ptr->connected && sub_ptr->socket != -1) {
                // Ensure buffer is reset if disconnect happened before POLLIN handler reset it
                sub_ptr->command_buffer.reset();
            }
            if (id_it != socket_to_id.end()) socket_to_id.erase(id_it); // Remove from socket map
            poll_fds.erase(poll_fds.begin() + i); // Remove from poll set
            // Continue to next fd index (loop handles index decrement)
        }

    } // End loop through client sockets
}
```


Contents of ../../Makefile:
```c++
CXX := g++
CPPFLAGS := -Iinclude
CXXFLAGS := -Wall -Wextra -g -std=c++17 -fPIC
LDFLAGS := -lm

SRC_DIR := src
LIB_DIR := lib
INC_DIR := include

SOURCES_SERVER := $(SRC_DIR)/server.cpp
SOURCES_SUBSCRIBER := $(SRC_DIR)/subscriber.cpp
SOURCES_COMMON := $(LIB_DIR)/common.cpp $(LIB_DIR)/circular_buffer.cpp

OBJECTS_SERVER := $(notdir $(SOURCES_SERVER:.cpp=.o))
OBJECTS_SUBSCRIBER := $(notdir $(SOURCES_SUBSCRIBER:.cpp=.o))
OBJECTS_COMMON := $(notdir $(SOURCES_COMMON:.cpp=.o))

ALL_OBJECTS := $(OBJECTS_SERVER) $(OBJECTS_SUBSCRIBER) $(OBJECTS_COMMON)

SERVER_EXEC := server
SUBSCRIBER_EXEC := subscriber
BINARY := $(SERVER_EXEC) $(SUBSCRIBER_EXEC)

VPATH := $(SRC_DIR):$(LIB_DIR)

all: $(BINARY)

$(SERVER_EXEC): $(OBJECTS_SERVER) $(OBJECTS_COMMON)
	@echo "Linking $@..."
	$(CXX) $^ -o $@ $(LDFLAGS)  # Use CXX, $^ includes both prerequisites

$(SUBSCRIBER_EXEC): $(OBJECTS_SUBSCRIBER) $(OBJECTS_COMMON)
	@echo "Linking $@..."
	$(CXX) $^ -o $@ $(LDFLAGS) # Use CXX, $^ includes both prerequisites

%.o: %.cpp $(INC_DIR)/* Makefile
	@echo "Compiling $< (found via VPATH) --> $@"
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@ # $< is the prerequisite (.cpp)

clean:
	@echo "Cleaning up..."
	rm -f $(ALL_OBJECTS) $(BINARY) core.* *~

.PHONY: all clean
```


in server.cpp the function handle_udp_message loops through two hashmaps: subscribers and sub.topics. Do you think you can keep a hashmap but with the elements reversed so you can reduce the time complexity?
Can you make the topicMatches even more efficient? Maybe use a trie? I don't know if it is a good ideea, but make it more efficient.
Do not change the the messages of the logs
Do not use global variables
AND WHATEVER YOU DO DO NOT CHANGE THE FUNCTIONALITY OF THE CODE
